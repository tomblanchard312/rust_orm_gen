/*
 * This code was generated by rust_orm_gen.
 * GitHub: https://github.com/tomblanchard312/rust_orm_gen
 * Date: 2024-07-26
 * Author: Tom Blanchard
 */

use tokio_postgres::Client;
use crate::query_builder::QueryBuilder;

pub async fn create_film(client: &Client, entity: &Film) -> Result<Film, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::insert::<Film>()
        .values(&[&entity.description, &entity.film_id, &entity.fulltext, &entity.language_id, &entity.last_update, &entity.length, &entity.rating, &entity.release_year, &entity.rental_duration, &entity.rental_rate, &entity.replacement_cost, &entity.special_features, &entity.title])
        .returning(&["description", "film_id", "fulltext", "language_id", "last_update", "length", "rating", "release_year", "rental_duration", "rental_rate", "replacement_cost", "special_features", "title"])
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Film {
        description: row.get("description"),
        film_id: row.get("film_id"),
        fulltext: row.get("fulltext"),
        language_id: row.get("language_id"),
        last_update: row.get("last_update"),
        length: row.get("length"),
        rating: row.get("rating"),
        release_year: row.get("release_year"),
        rental_duration: row.get("rental_duration"),
        rental_rate: row.get("rental_rate"),
        replacement_cost: row.get("replacement_cost"),
        special_features: row.get("special_features"),
        title: row.get("title"),
    })
}

pub async fn get_film(client: &Client, id: i32) -> Result<Film, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::select::<Film>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Film {
        description: row.get("description"),
        film_id: row.get("film_id"),
        fulltext: row.get("fulltext"),
        language_id: row.get("language_id"),
        last_update: row.get("last_update"),
        length: row.get("length"),
        rating: row.get("rating"),
        release_year: row.get("release_year"),
        rental_duration: row.get("rental_duration"),
        rental_rate: row.get("rental_rate"),
        replacement_cost: row.get("replacement_cost"),
        special_features: row.get("special_features"),
        title: row.get("title"),
    })
}

pub async fn update_film(client: &Client, entity: &Film) -> Result<Film, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::update::<Film>()
        .set_values(&[("description", &entity.description), ("film_id", &entity.film_id), ("fulltext", &entity.fulltext), ("language_id", &entity.language_id), ("last_update", &entity.last_update), ("length", &entity.length), ("rating", &entity.rating), ("release_year", &entity.release_year), ("rental_duration", &entity.rental_duration), ("rental_rate", &entity.rental_rate), ("replacement_cost", &entity.replacement_cost), ("special_features", &entity.special_features), ("title", &entity.title)])
        .where_clause("id = $1")
        .bind_param(entity.id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Film {
        description: row.get("description"),
        film_id: row.get("film_id"),
        fulltext: row.get("fulltext"),
        language_id: row.get("language_id"),
        last_update: row.get("last_update"),
        length: row.get("length"),
        rating: row.get("rating"),
        release_year: row.get("release_year"),
        rental_duration: row.get("rental_duration"),
        rental_rate: row.get("rental_rate"),
        replacement_cost: row.get("replacement_cost"),
        special_features: row.get("special_features"),
        title: row.get("title"),
    })
}

pub async fn delete_film(client: &Client, id: i32) -> Result<bool, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::delete::<Film>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let result = client.execute(&query, &params[..]).await?;
    
    Ok(result > 0)
}

pub async fn list_film(client: &Client, limit: Option<i64>, offset: Option<i64>) -> Result<Vec<Film>, tokio_postgres::Error> {
    let mut query_builder = QueryBuilder::select::<Film>();
    
    if let Some(limit_val) = limit {
        query_builder = query_builder.limit(limit_val as usize);
    }
    
    if let Some(offset_val) = offset {
        query_builder = query_builder.offset(offset_val as usize);
    }
    
    let (query, params) = query_builder.build();
    
    let rows = client.query(&query, &params[..]).await?;
    
    let entities = rows.into_iter().map(|row| Film {
        description: row.get("description"),
        film_id: row.get("film_id"),
        fulltext: row.get("fulltext"),
        language_id: row.get("language_id"),
        last_update: row.get("last_update"),
        length: row.get("length"),
        rating: row.get("rating"),
        release_year: row.get("release_year"),
        rental_duration: row.get("rental_duration"),
        rental_rate: row.get("rental_rate"),
        replacement_cost: row.get("replacement_cost"),
        special_features: row.get("special_features"),
        title: row.get("title"),
    }).collect();
    
    Ok(entities)
}
