/*
 * This code was generated by rust_orm_gen.
 * GitHub: https://github.com/tomblanchard312/rust_orm_gen
 * Date: 2024-07-26
 * Author: Tom Blanchard
 */

use tokio_postgres::Client;
use crate::query_builder::QueryBuilder;

pub async fn create_staff(client: &Client, entity: &Staff) -> Result<Staff, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::insert::<Staff>()
        .values(&[&entity.active, &entity.address_id, &entity.email, &entity.first_name, &entity.last_name, &entity.last_update, &entity.password, &entity.picture, &entity.staff_id, &entity.store_id, &entity.username])
        .returning(&["active", "address_id", "email", "first_name", "last_name", "last_update", "password", "picture", "staff_id", "store_id", "username"])
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Staff {
        active: row.get("active"),
        address_id: row.get("address_id"),
        email: row.get("email"),
        first_name: row.get("first_name"),
        last_name: row.get("last_name"),
        last_update: row.get("last_update"),
        password: row.get("password"),
        picture: row.get("picture"),
        staff_id: row.get("staff_id"),
        store_id: row.get("store_id"),
        username: row.get("username"),
    })
}

pub async fn get_staff(client: &Client, id: i32) -> Result<Staff, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::select::<Staff>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Staff {
        active: row.get("active"),
        address_id: row.get("address_id"),
        email: row.get("email"),
        first_name: row.get("first_name"),
        last_name: row.get("last_name"),
        last_update: row.get("last_update"),
        password: row.get("password"),
        picture: row.get("picture"),
        staff_id: row.get("staff_id"),
        store_id: row.get("store_id"),
        username: row.get("username"),
    })
}

pub async fn update_staff(client: &Client, entity: &Staff) -> Result<Staff, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::update::<Staff>()
        .set_values(&[("active", &entity.active), ("address_id", &entity.address_id), ("email", &entity.email), ("first_name", &entity.first_name), ("last_name", &entity.last_name), ("last_update", &entity.last_update), ("password", &entity.password), ("picture", &entity.picture), ("staff_id", &entity.staff_id), ("store_id", &entity.store_id), ("username", &entity.username)])
        .where_clause("id = $1")
        .bind_param(entity.id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(Staff {
        active: row.get("active"),
        address_id: row.get("address_id"),
        email: row.get("email"),
        first_name: row.get("first_name"),
        last_name: row.get("last_name"),
        last_update: row.get("last_update"),
        password: row.get("password"),
        picture: row.get("picture"),
        staff_id: row.get("staff_id"),
        store_id: row.get("store_id"),
        username: row.get("username"),
    })
}

pub async fn delete_staff(client: &Client, id: i32) -> Result<bool, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::delete::<Staff>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let result = client.execute(&query, &params[..]).await?;
    
    Ok(result > 0)
}

pub async fn list_staff(client: &Client, limit: Option<i64>, offset: Option<i64>) -> Result<Vec<Staff>, tokio_postgres::Error> {
    let mut query_builder = QueryBuilder::select::<Staff>();
    
    if let Some(limit_val) = limit {
        query_builder = query_builder.limit(limit_val as usize);
    }
    
    if let Some(offset_val) = offset {
        query_builder = query_builder.offset(offset_val as usize);
    }
    
    let (query, params) = query_builder.build();
    
    let rows = client.query(&query, &params[..]).await?;
    
    let entities = rows.into_iter().map(|row| Staff {
        active: row.get("active"),
        address_id: row.get("address_id"),
        email: row.get("email"),
        first_name: row.get("first_name"),
        last_name: row.get("last_name"),
        last_update: row.get("last_update"),
        password: row.get("password"),
        picture: row.get("picture"),
        staff_id: row.get("staff_id"),
        store_id: row.get("store_id"),
        username: row.get("username"),
    }).collect();
    
    Ok(entities)
}
