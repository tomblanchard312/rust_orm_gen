/*
 * This code was generated by rust_orm_gen.
 * GitHub: https://github.com/tomblanchard312/rust_orm_gen
 * Date: 2024-07-26
 * Author: Tom Blanchard
 */

use tokio_postgres::Client;
use crate::query_builder::QueryBuilder;

pub async fn create_customer_list(client: &Client, entity: &CustomerList) -> Result<CustomerList, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::insert::<CustomerList>()
        .values(&[&entity.address, &entity.city, &entity.country, &entity.id, &entity.name, &entity.notes, &entity.phone, &entity.sid, &entity.zip_code])
        .returning(&["address", "city", "country", "id", "name", "notes", "phone", "sid", "zip code"])
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(CustomerList {
        address: row.get("address"),
        city: row.get("city"),
        country: row.get("country"),
        id: row.get("id"),
        name: row.get("name"),
        notes: row.get("notes"),
        phone: row.get("phone"),
        sid: row.get("sid"),
        zip_code: row.get("zip code"),
    })
}

pub async fn get_customer_list(client: &Client, id: i32) -> Result<CustomerList, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::select::<CustomerList>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(CustomerList {
        address: row.get("address"),
        city: row.get("city"),
        country: row.get("country"),
        id: row.get("id"),
        name: row.get("name"),
        notes: row.get("notes"),
        phone: row.get("phone"),
        sid: row.get("sid"),
        zip_code: row.get("zip code"),
    })
}

pub async fn update_customer_list(client: &Client, entity: &CustomerList) -> Result<CustomerList, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::update::<CustomerList>()
        .set_values(&[("address", &entity.address), ("city", &entity.city), ("country", &entity.country), ("id", &entity.id), ("name", &entity.name), ("notes", &entity.notes), ("phone", &entity.phone), ("sid", &entity.sid), ("zip code", &entity.zip_code)])
        .where_clause("id = $1")
        .bind_param(entity.id)
        .build();
    
    let row = client.query_one(&query, &params[..]).await?;
    
    Ok(CustomerList {
        address: row.get("address"),
        city: row.get("city"),
        country: row.get("country"),
        id: row.get("id"),
        name: row.get("name"),
        notes: row.get("notes"),
        phone: row.get("phone"),
        sid: row.get("sid"),
        zip_code: row.get("zip code"),
    })
}

pub async fn delete_customer_list(client: &Client, id: i32) -> Result<bool, tokio_postgres::Error> {
    let (query, params) = QueryBuilder::delete::<CustomerList>()
        .where_clause("id = $1")
        .bind_param(id)
        .build();
    
    let result = client.execute(&query, &params[..]).await?;
    
    Ok(result > 0)
}

pub async fn list_customer_list(client: &Client, limit: Option<i64>, offset: Option<i64>) -> Result<Vec<CustomerList>, tokio_postgres::Error> {
    let mut query_builder = QueryBuilder::select::<CustomerList>();
    
    if let Some(limit_val) = limit {
        query_builder = query_builder.limit(limit_val as usize);
    }
    
    if let Some(offset_val) = offset {
        query_builder = query_builder.offset(offset_val as usize);
    }
    
    let (query, params) = query_builder.build();
    
    let rows = client.query(&query, &params[..]).await?;
    
    let entities = rows.into_iter().map(|row| CustomerList {
        address: row.get("address"),
        city: row.get("city"),
        country: row.get("country"),
        id: row.get("id"),
        name: row.get("name"),
        notes: row.get("notes"),
        phone: row.get("phone"),
        sid: row.get("sid"),
        zip_code: row.get("zip code"),
    }).collect();
    
    Ok(entities)
}
